float2 hash(int x, int y, int seed) {
  int hash = x * 73856093 ^ y * 19349663 ^ seed * 83492791;
  hash = ((hash >> 13) ^ hash >> 7);
  float angle = (float)hash;
  return (float2)(cos(angle), sin(angle));
}

float2 lerp(float2 a, float2 b, float t) {
  return a + t * (b - a);
}

const int2 offsets[4] = {(int2)(0, 0), (int2)(1, 0), (int2)(0, 1), (int2)(1, 1)};

float2 noise(float2 coords) {
  int2 i = (int2)(floor(coords.x), floor(coords.y));

  float2 gradients[4];
  for (int j = 0; j < 4; j++) {
    gradients[j] = hash(i.x + offsets[j].x, i.y + offsets[j].y, 0);
  }

  float2 dists[4];
  for (int j = 0; j < 4; j++) {
    dists[j] = coords - (float2)(i.x + offsets[j].x, i.y + offsets[j].y);
  }

  float2 dotProducts[4];
  for (int j = 0; j < 4; j++) {
    dotProducts[j] = dot(dists[j], gradients[j]);
  }

  float x = smoothstep(0.0f, 1.0f, coords.x - i.x);
  float y = smoothstep(0.0f, 1.0f, coords.y - i.y);

  float2 a = lerp(dotProducts[0], dotProducts[1], x);
  float2 b = lerp(dotProducts[2], dotProducts[3], x);

  float2 out = lerp(a, b, y);
  return out * 0.5f + 0.5f;
}

const __constant float longs[4] = {439.0f, 1710.0f, 5474.0f, 2403.0f};
const __constant float shorts[4] = {30.0f, 6.0f, 60.0f, 3.0f};

const float4 applyWavelengths(__constant const float wavelengths[4], int x, int y, const float4 colors[4], const float scale, float4 bias) {
  for (int i = 0; i < 4; i++) {
    float2 p = (float2)(x, y) / wavelengths[i];
    float2 calc = noise(p);
    bias += colors[i] * calc.x * scale;
  }
  bias.w = 1.0f;
  return bias;
}

__constant const float3 colorDeltas[4] = {
  (float3)(0.0f, 0.1f, 0.0f),
  (float3)(0.0f, 0.0f, 0.1f),
  (float3)(-0.2f, 0.1f, 0.1f),
  (float3)(0.1f, -0.2f, 0.1f)
};

__kernel void nebula(__global float4 *out, __global float4 *featureParams, __global float4 *featureColors, int featureCount) {
  int x = get_global_id(0);
  int y = get_global_id(1);

  int oX = x - get_global_offset(0);
  int oY = y - get_global_offset(1);

  int flatCoord = (oY * get_global_size(0) + oX);

  const float4 allWhite[4] = {(float4)(0.8f, 0.8f, 1.0f, 1.0), (float4)(0.9f, 0.8f, 1.0f, 1.0), (float4)(1.0f, 0.9f, 0.8f, 1.0), (float4)(1.0f, 1.0f, 1.0f, 1.0)};
  float4 nebulaColors[4];

  float3 featureColor = (float3)(0.0f, 0.0f, 0.0f);

  float totalStrength = 0.0f;

  for (int i = 0; i < featureCount; i++) {
    float2 coords = (float2)(x, y);
    float2 center = featureParams[i].xy;
    float radius = featureParams[i].z;
    float strength = featureParams[i].w;

    float dist = length(coords - center);

    float falloff = max(1.0f - dist / radius, 0.0f);

    float3 color = featureColors[i].xyz;
    
    featureColor += color * strength * (falloff + 0.1f);
    totalStrength += strength * falloff;
  }

  float bias = log(totalStrength + 1.0f) * 0.5f;

  featureColor = normalize(featureColor);

  nebulaColors[0] = (float4)(featureColor + colorDeltas[0], 1.0f);
  nebulaColors[1] = (float4)(featureColor + colorDeltas[1], 1.0f);
  nebulaColors[2] = (float4)(featureColor + colorDeltas[2], 1.0f);
  nebulaColors[3] = (float4)(featureColor + colorDeltas[3], 1.0f);

  float4 first = applyWavelengths(longs, x, y, allWhite, 1.0f, (float4)(0.0f, 0.0f, 0.0f, 0.0f));
  float4 second = applyWavelengths(shorts, x, y, nebulaColors, 0.4f, (float4)(1.0f, 1.0f, 1.3f, 0.1f + bias));
  float4 ret = clamp(second - first, (float4)(0.0f, 0.0f, 0.0f, 0.0f), (float4)(1.0f, 1.0f, 1.0f, 0.0f));

  float alpha = length(ret.xyz) * 0.5f;

  out[flatCoord] = (float4)(ret.xyz, alpha);
}

const float4 doStars(__constant const float wavelengths[5], int x, int y, __constant const float biases[5], const float scales[5]) {
  float value = 0.0f;
  for (int i = 0; i < 5; i++) {
    float2 p = (float2)(x, y) / wavelengths[i];
    float2 calc = noise(p);
    calc.x = clamp(calc.x + biases[i], 0.0f, 1.0f) * scales[i];
    value += calc.x;
  }
  value /= 5.0f;
  value = smoothstep(0.5f, 0.63f, value);
  return (float4)(value, value, value, value);
}

const __constant float starBackgroundWavelengths[5] = {2.0f, 3.0f, 5.0f, 15.0f, 100.0f};
const __constant float starForegroundWavelengths[5] = {3.0f, 4.0f, 5.0f, 20.0f, 200.0f};
const __constant float starBiases[5] = {0.0f, -0.1f, 0.0f, -0.4f, -0.4f};
const __constant float starScales[5] = {1.0f, 2.0f, 1.0f, 0.5f, 0.5f};

__kernel void starBackground(__global float4 *out, __global float4 *featureParams, int featureCount) {
  // feature param is x, y, radius, strength, 
  int x = get_global_id(0);
  int y = get_global_id(1);

  int oX = x - get_global_offset(0);
  int oY = y - get_global_offset(1);

  float globularStrength = 0.0f;
  for(int i = 0; i < featureCount; i++) {
    float2 coords = (float2)(x, y);
    float2 center = featureParams[i].xy;
    float radius = featureParams[i].z;
    float strength = featureParams[i].w;

    float dist = length(coords - center);
    if (dist > radius) continue;

    float falloff = 1.0f - dist / radius;
    globularStrength += strength * cbrt(falloff);
  }

  // create a copy of the star scaless
  float starScalesCopy[5] = {starScales[0], starScales[1], starScales[2], starScales[3], starScales[4]};
  starScalesCopy[0] += globularStrength / 3.0;
  starScalesCopy[1] += globularStrength / 3.0;
  starScalesCopy[4] += globularStrength / 4.0;

  int flatCoord = (oY * get_global_size(0) + oX);

  out[flatCoord] = doStars(starBackgroundWavelengths, x, y, starBiases, starScalesCopy);
}

__kernel void mixLayers(__global float4 *layer0, __global float4 *layer1, __global float4 *out) {
  int x = get_global_id(0);
  int y = get_global_id(1);

  int flatCoord = (y * get_global_size(0) + x);

  float3 color = mix(layer0[flatCoord].xyz, layer1[flatCoord].xyz, layer1[flatCoord].w);

  out[flatCoord] = (float4)(color, 1.0f);
}

__kernel void clear(__global float4 *out) {
  int x = get_global_id(0);
  int y = get_global_id(1);

  int flatCoord = (y * get_global_size(0) + x);

  out[flatCoord] = (float4)(0.0f, 0.0f, 0.0f, 1.0f);
}

__kernel void starForeground(__global float4 *out) {
  int x = get_global_id(0);
  int y = get_global_id(1);

  int oX = x - get_global_offset(0);
  int oY = y - get_global_offset(1);

  int flatCoord = (oY * get_global_size(0) + oX);

  float starScalesCopy[5] = {starScales[0], starScales[1], starScales[2], starScales[3], starScales[4]};

  // starScalesCopy[0] += 3.0f;
  // starScalesCopy[1] += 3.0f;
  // starScalesCopy[2] += 3.0f;
  // starScalesCopy[3] += 3.0f;
  // starScalesCopy[4] += 3.0f;

  out[flatCoord] = doStars(starForegroundWavelengths, x, y, starBiases, starScalesCopy);
}
